name: Android Build & Sign & Release

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    # 关键：授予Action推送代码的权限
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 拉取完整提交历史
          persist-credentials: true # 保留凭证用于推送代码

      - name: Set up JDK 8
        uses: actions/setup-java@v4
        with:
          java-version: '8'
          distribution: 'temurin'
          cache: gradle

      # 安装zipalign依赖
      - name: Install Android SDK Build Tools
        run: |
          sudo apt update
          sudo apt install -y android-sdk-build-tools

      # 自动递增版本号（带默认值兜底，修复sed语法兼容）
      - name: Auto increment version code and name
        run: |
          BUILD_GRADLE_PATH="app/build.gradle"
          # 读取当前版本号（保留你原有逻辑，修复grep/sed兼容）
          CURRENT_VERSION_NAME=$(grep -oP 'versionName "\K[^"]+' $BUILD_GRADLE_PATH || echo "1.0.0")
          CURRENT_VERSION_CODE=$(grep -oP 'versionCode \K\d+' $BUILD_GRADLE_PATH || echo "1")
          
          # 计算新版本号（保留你原有逻辑）
          NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))
          NEW_VERSION_NAME=$(echo $CURRENT_VERSION_NAME | awk -F. '{print $1"."$2"."$3+1}')
          
          echo "Current version: $CURRENT_VERSION_NAME (code: $CURRENT_VERSION_CODE)"
          echo "New version: $NEW_VERSION_NAME (code: $NEW_VERSION_CODE)"
          
          # 修复sed语法：兼容Ubuntu系统，添加.bak备份（避免语法错误）
          # 新增/替换versionCode
          if ! grep -q "versionCode" $BUILD_GRADLE_PATH; then
            sed -i.bak '/defaultConfig {/a \        versionCode '"$NEW_VERSION_CODE" $BUILD_GRADLE_PATH
            rm -f "${BUILD_GRADLE_PATH}.bak"
          else
            sed -i.bak "s/versionCode $CURRENT_VERSION_CODE/versionCode $NEW_VERSION_CODE/" $BUILD_GRADLE_PATH
            rm -f "${BUILD_GRADLE_PATH}.bak"
          fi
          
          # 新增/替换versionName（核心：修改build.gradle中的versionName）
          if ! grep -q "versionName" $BUILD_GRADLE_PATH; then
            sed -i.bak '/defaultConfig {/a \        versionName "'"$NEW_VERSION_NAME"'"' $BUILD_GRADLE_PATH
            rm -f "${BUILD_GRADLE_PATH}.bak"
          else
            sed -i.bak "s/versionName \"$CURRENT_VERSION_NAME\"/versionName \"$NEW_VERSION_NAME\"/" $BUILD_GRADLE_PATH
            rm -f "${BUILD_GRADLE_PATH}.bak"
          fi
          
          echo "NEW_VERSION_NAME=$NEW_VERSION_NAME" >> $GITHUB_ENV
          echo "NEW_VERSION_CODE=$NEW_VERSION_CODE" >> $GITHUB_ENV

      # ========== 新增核心步骤：提交版本号修改到代码库 ==========
      - name: Commit version bump to repository
        run: |
          # 配置git用户信息（Action提交代码用）
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # 检查build.gradle是否真的有修改（避免空提交）
          if git diff --quiet $BUILD_GRADLE_PATH; then
            echo "Version info not changed, skip commit"
          else
            # 提交修改后的build.gradle
            git add $BUILD_GRADLE_PATH
            git commit -m "chore: bump version to v$NEW_VERSION_NAME (build $NEW_VERSION_CODE)"
            # 推送到当前分支（main/master）
            git push origin "${{ github.ref }}"
            echo "✅ Version name/code updated and committed to repo"
          fi

      # 解密keystore（若未加密则跳过，补充容错）
      - name: Decrypt keystore
        if: ${{ secrets.GPG_PASSWORD && secrets.KEYSTORE_FILE }} # 修复if条件语法
        run: |
          gpg --quiet --batch --yes --decrypt --passphrase="${{ secrets.GPG_PASSWORD }}" \
          --output my-release-key.keystore ${{ secrets.KEYSTORE_FILE }}
          # 验证keystore是否生成
          if [ ! -f "my-release-key.keystore" ]; then
            echo "Keystore decrypt failed!" && exit 1
          fi

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build Release APK
        run: ./gradlew assembleRelease --no-daemon

      - name: Sign APK
        run: |
          # 补充容错：检查APK是否存在
          APK_PATH=$(find app/build/outputs/apk/release -name "app-release-unsigned.apk")
          if [ -z "$APK_PATH" ]; then
            echo "Unsigned APK not found!" && exit 1
          fi
          
          jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 \
          -keystore my-release-key.keystore \
          -storepass ${{ secrets.KEYSTORE_PASSWORD }} \
          -keypass ${{ secrets.KEY_PASSWORD }} \
          $APK_PATH ${{ secrets.KEY_ALIAS }}
          # 带版本号命名APK
          /usr/bin/zipalign -v 4 $APK_PATH app/build/outputs/apk/release/app-v${{ env.NEW_VERSION_NAME }}-release-signed.apk

      # 自动发布到GitHub Release
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.NEW_VERSION_NAME }}
          name: Release v${{ env.NEW_VERSION_NAME }} (build ${{ env.NEW_VERSION_CODE }})
          body: |
            ## 自动发布的番茄钟APP
            - 版本号：v${{ env.NEW_VERSION_NAME }}
            - 构建号：${{ env.NEW_VERSION_CODE }}
            - 发布时间：${{ github.event.head_commit.timestamp }}
          files: app/build/outputs/apk/release/app-v${{ env.NEW_VERSION_NAME }}-release-signed.apk
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean up keystore
        if: always()
        run: rm -f my-release-key.keystore
